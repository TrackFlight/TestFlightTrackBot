// Code generated by sqlgen. DO NOT EDIT.

package db

import (
{{- range .Imports }}
    "{{.}}"
{{- end }}
    "github.com/valkey-io/valkey-go"
    "context"
)

{{$rawName := .StoreName | ToPascalCase -}}
{{$name := printf "%sStore" $rawName -}}
type {{$name}} struct {
    db DBTX
    cx context.Context
    redis valkey.Client
}
{{ range .Queries -}}
{{$queryName := .Name | ToCamelCase}}
{{- $isMany := eq .Cmd ":many"}}
{{- $isBulk := IsBulkQuery .}}
{{- $isSingleBulk := eq (len .Params) 1}}
const {{$queryName}} = `{{.Text}}`
{{- $returnName := printf "%s%sRow" .Name $rawName}}
{{- $allowPointer := not $isMany}}
{{- if eq (len .Columns) 1 -}}
{{- $allowPointer = false}}
{{- $returnName = ToGoType (index .Columns 0) false -}}
{{- end }}
{{- $checkCompatible := ""}}
{{- $bulkParamsName := printf "%s%sParams" (.Name | ToPascalCase) $rawName}}
{{- if and $isBulk (not $isSingleBulk) }}
type {{$bulkParamsName}} struct {
{{- range .Params}}
{{- if .Column.IsArray}}
    {{.Column.Name | ToPascalCase | Singular | ToGoCase}} {{ToGoType .Column true}}
{{- end }}
{{- end}}
}
{{- end}}
{{- if gt (len .Columns) 1 }}
{{- $checkCompatible = FindCompatible (index .Columns 0).Table.Name .Columns}}
{{- if gt (len $checkCompatible) 0 }}
{{- $returnName = printf "models.%s" ($checkCompatible | ToPascalCase | Singular) -}}
{{- else}}

type {{$returnName}} struct {
{{- range .Columns }}
    {{.Name | ToPascalCase | ToGoCase}} {{ToGoType . true}} `json:"{{.Name}}{{if not .NotNull}},omitempty{{end}}"`
{{- end }}
}
{{- end }}
{{- end }}

func (ctx *{{$name}}) {{.Name}}(
{{- $first := true -}}
{{- $addedBulk := true -}}
{{- $queryOptions := (GetQueryOptions .)}}
{{- range (GetParamsOrdered . $queryOptions.Order) -}}
{{- if not (and $isBulk .Column.IsArray (not $isSingleBulk)) -}}
{{- if not $first}}, {{end -}}
{{- .Column.Name | ToCamelCase}} {{ if .Column.IsArray -}}[]{{- end -}}{{ToGoType .Column true}}
{{- else if $addedBulk -}}
{{- if not $first}}, {{end -}}
bulkParams []{{$bulkParamsName}}
{{- $addedBulk = false -}}
{{- end -}}
{{- $first = false -}}
{{ end -}}
) {{if gt (len .Columns) 0 -}}({{ if $isMany -}}[]{{else if $allowPointer -}}*{{- end -}}
{{$returnName -}}, error)
{{- else -}} error
{{- end }} {
    {{- if not (eq .Cmd ":exec") }}
    var i {{ if $isMany -}}[]{{- end -}}{{$returnName}}
    {{- end}}
    {{- if $isBulk }}
    {{- if not $isSingleBulk }}
    {{- range .Params}}
    {{- if .Column.IsArray}}
    var {{.Column.Name | ToCamelCase}} []{{ToGoType .Column true}}
    {{- end}}
    {{- end}}
    for _, params := range bulkParams {
        {{- range .Params}}
        {{- if .Column.IsArray}}
        {{- $listName := .Column.Name | ToCamelCase}}
        {{$listName}} = append({{$listName}}, params.{{.Column.Name | ToPascalCase | Singular | ToGoCase}})
        {{- end}}
        {{- end}}
    }
    {{- end}}
    tx, err := ctx.db.Begin(ctx.cx)
    if err != nil {
        return {{ if not (eq .Cmd ":exec") -}}nil, {{end}}err
    }
    defer tx.Rollback(ctx.cx)
    totalSize := len({{- if not $isSingleBulk }}bulkParams{{else}}{{(index .Params 0).Column.Name | ToCamelCase}}{{end}})
    for start := 0; start < totalSize; start += batchMaxSize {
        end := start + batchMaxSize
        if end > totalSize {
        	end = totalSize
        }
    {{- end}}
    {{- $cacheOptions := $queryOptions.Cache}}
    {{- $tableSingularName := $cacheOptions.Table | Singular}}
    {{- $allowedGetCache := and $cacheOptions.Allow (not (eq .Cmd ":exec")) (eq $cacheOptions.Kind "get") (not $isBulk)}}
    {{- if or $allowedGetCache (eq $cacheOptions.Kind "remove")}}
    {{- if not (and (contains $cacheOptions.Fields "all") (eq (len $cacheOptions.Fields) 1))}}
    {{- if $cacheOptions.Key}}
    valkeyKey := fmt.Sprintf("{{$tableSingularName}}:{{GetSprintfFormat . $cacheOptions.Key}}", {{$cacheOptions.Key | ToCamelCase}})
    {{- else}}
    valkeyKey := "{{$tableSingularName}}:list"
    {{- end }}
    {{- end }}
    {{- end }}
    {{- if $allowedGetCache}}
    valkeyField := "{{if eq (len .Columns) 1}}{{(index .Columns 0).Name}}{{else}}{{- if and $cacheOptions.Key (not $isMany)}}__row{{else}}__all{{- end -}}{{- end -}}"
    err := ctx.redis.Do(
        ctx.cx,
        ctx.redis.B().Hget().Key(valkeyKey).Field(valkeyField).Build(),
    ).DecodeJSON(&i)
    if err == nil {
        return i, nil
    }
    {{- end }}
    {{if eq .Cmd ":one" -}}
    row
    {{- else if $isMany -}}
    rows, errQuery
    {{- else -}}
    tag, errScan
    {{- end}} := {{ if $isBulk }}tx{{else}}ctx.db{{end}}.{{- if eq .Cmd ":one" -}}
    QueryRow
    {{- else if $isMany -}}
    Query
    {{- else -}}
    Exec
    {{- end -}}(
        ctx.cx,
        {{$queryName}},
        {{- range .Params}}
        {{.Column.Name | ToCamelCase}}{{ if and $isBulk .Column.IsArray }}[start:end]{{end}},
        {{- end }}
    )
    {{- if or (eq .Cmd ":one") $isMany}}
    {{- $tmpVarName := "i"}}
    {{- if $isMany}}
    {{- $tmpVarName = "item"}}
    defer rows.Close()
    if errQuery != nil {
        return nil, errQuery
    }
    for rows.Next() {
        var item {{$returnName}}
        errScan := rows.Scan(
    {{- else if eq .Cmd ":one"}}
    errScan := row.Scan(
    {{- end}}
    {{- if gt (len .Columns) 1}}
    {{- range .Columns}}
    &{{$tmpVarName}}.{{.Name | ToPascalCase | ToGoCase}},
    {{- end }}
    {{ else -}}
    &{{$tmpVarName}}
    {{- end -}})
    if errScan != nil {
        if errors.Is(errScan, pgx.ErrNoRows) {
        	errScan = nil
        }
        return {{ if or $isMany $allowPointer }}nil{{else}}i{{- end}}, errScan
    }
    {{- if or $isMany }}
        i = append(i, item)
    }
    if rows.Err() != nil {
        return nil, rows.Err()
    }
    {{- end}}
    {{- end}}
    {{- if eq .Cmd ":exec" }}
        if errScan != nil {
            return errScan
        }
        if tag.RowsAffected() == 0 {
            return pgx.ErrNoRows
        }
    {{- end}}
    {{- if $allowedGetCache}}
    jsonData, err := json.Marshal(i)
    if err != nil {
        return i, err
    }
    ctx.redis.DoMulti(
        ctx.cx,
        ctx.redis.B().Hset().Key(valkeyKey).FieldValue().FieldValue(valkeyField, string(jsonData)).Build(),
        ctx.redis.B().Expire().Key(valkeyKey).Seconds({{$cacheOptions.TTL}}).Build(),
    )
    {{- else if eq $cacheOptions.Kind "remove"}}
    ctx.redis.Do{{- if gt (len $cacheOptions.Fields) 1 }}Multi{{end}}(
        ctx.cx,
        {{- range $cacheOptions.Fields }}
        {{- if eq . "all"}}
        ctx.redis.B().Hdel().Key("{{$tableSingularName}}:list").Field("__all").Build(),
        {{- else if eq . "all_by_key"}}
        ctx.redis.B().Hdel().Key(valkeyKey).Field("__all").Build(),
        {{- else if eq . "row"}}
        ctx.redis.B().Hdel().Key(valkeyKey).Field("__row").Build(),
        {{- else}}
        ctx.redis.B().Hdel().Key(valkeyKey).Field("{{.}}").Build(),
        {{- end }}
        {{- end }}
    )
    {{- end }}
    {{- if $isBulk }}
    }
    if errComm := tx.Commit(ctx.cx); errComm != nil {
        return {{ if not (eq .Cmd ":exec") -}}nil, {{end}}errComm
    }
    {{- end}}
    return {{ if not (eq .Cmd ":exec") -}}{{if $allowPointer -}}&{{- end -}}i, {{end}}nil
}
{{ end -}}